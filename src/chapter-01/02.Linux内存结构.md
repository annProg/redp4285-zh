## Linux 内存结构
为了执行进程，Linux 内核将内存区域的一部分分配给请求进程。进程使用内存区域作为工作区并执行所需的工作。这就像你分配了自己的办公桌，然后用桌面分散纸张、文件和备忘录来完成你的工作。不同之处在于内核必须以更动态的方式分配空间。运行的进程数量有时会达到数万个，而内存数量通常是有限的。因此，Linux 内核必须有效地处理内存。在本节中，我们将描述 Linux 的内存体系结构、地址布局以及 Linux 如何有效地管理内存空间。

### 物理内存和虚拟内存
今天，我们面临着 32 位系统和 64 位系统的选择。对于企业级客户机来说，最重要的区别之一是虚拟内存地址可能超过 4GB。从性能的角度来看，了解 Linux 内核如何将物理内存映射到 32 位和 64 位系统上的虚拟内存是很有趣的。

正如您在 [@fig:memory_layout] 中所看到的，在 32 位和 64 位系统中，Linux 内核处理内存的方式有明显的不同。详细探讨物理到虚拟的映射超出了本文的范围，在此我们仅强调一些 Linux 内存架构的细节。

![32 位和 64 位系统的 Linux 内核内存布局](images/memory_layout.jpg){#fig:memory_layout}

在 32 位体系结构（如 IA-32) 上，Linux 内核只能直接访问物理内存的前千兆字节（考虑预留范围时为 896 MB)。超出 ZONE_NORMAL 的内存需要映射到 1GB 以下。这种映射对应用程序是完全透明的，但是在 ZONE_HIGHMEM 中分配内存页会导致性能略有下降。

另一方面，对于 x86-64（以及 x64) 这样的 64 位架构，ZONE_NORMAL 可以一直扩展到 64 GB，在 IA-64 系统中可以扩展到 128 GB。可以看到，通过使用 64 位体系结构，可以消除将内存页从 ZONE_HIGHMEM 映射到 ZONE_NORMAL 的开销。

#### 虚拟内存寻址布局
[@fig:vm_address_layout] 显示用于 32 位和 64 位体系结构的 Linux 虚拟寻址布局。

![32 位和 64 位架构的虚拟内存寻址布局](images/vm_address_layout.jpg){#fig:vm_address_layout}

在 32 位体系结构上，单个进程可以访问的最大地址空间是 4GB。这是从 32 位虚拟寻址派生出来的限制。在标准实现中，虚拟地址空间被划分为 3GB 的用户空间和 1GB 的内核空间。有一些变体，如 4G/4G 寻址布局实现。

另一方面，在 64 位体系结构（如 x86_64 和 ia64) 上，没有这样的限制。每个进程都可以从巨大的地址空间中受益。

### 虚拟内存管理