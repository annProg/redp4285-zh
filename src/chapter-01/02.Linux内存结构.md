## Linux 内存结构
为了执行进程，Linux 内核将内存区域的一部分分配给请求进程。进程使用内存区域作为工作区并执行所需的工作。这就像你分配了自己的办公桌，然后用桌面分散纸张、文件和备忘录来完成你的工作。不同之处在于内核必须以更动态的方式分配空间。运行的进程数量有时会达到数万个，而内存数量通常是有限的。因此，Linux 内核必须有效地处理内存。在本节中，我们将描述 Linux 的内存体系结构、地址布局以及 Linux 如何有效地管理内存空间。

### 物理内存和虚拟内存
今天，我们面临着 32 位系统和 64 位系统的选择。对于企业级客户机来说，最重要的区别之一是虚拟内存地址可能超过 4GB。从性能的角度来看，了解 Linux 内核如何将物理内存映射到 32 位和 64 位系统上的虚拟内存是很有趣的。

正如您在 [@fig:memory_layout] 中所看到的，在 32 位和 64 位系统中，Linux 内核处理内存的方式有明显的不同。详细探讨物理到虚拟的映射超出了本文的范围，在此我们仅强调一些 Linux 内存架构的细节。

![32 位和 64 位系统的 Linux 内核内存布局](images/memory_layout.jpg){#fig:memory_layout width=70% height=50%}

在 32 位体系结构（如 IA-32) 上，Linux 内核只能直接访问物理内存的前千兆字节（考虑预留范围时为 896 MB)。超出 ZONE_NORMAL 的内存需要映射到 1GB 以下。这种映射对应用程序是完全透明的，但是在 ZONE_HIGHMEM 中分配内存页会导致性能略有下降。

另一方面，对于 x86-64（以及 x64) 这样的 64 位架构，ZONE_NORMAL 可以一直扩展到 64 GB，在 IA-64 系统中可以扩展到 128 GB。可以看到，通过使用 64 位体系结构，可以消除将内存页从 ZONE_HIGHMEM 映射到 ZONE_NORMAL 的开销。

#### 虚拟内存寻址布局
[@fig:vm_address_layout] 显示用于 32 位和 64 位体系结构的 Linux 虚拟寻址布局。

![32 位和 64 位架构的虚拟内存寻址布局](images/vm_address_layout.jpg){#fig:vm_address_layout width=70%}

在 32 位体系结构上，单个进程可以访问的最大地址空间是 4GB。这是从 32 位虚拟寻址派生出来的限制。在标准实现中，虚拟地址空间被划分为 3GB 的用户空间和 1GB 的内核空间。有一些变体，如 4G/4G 寻址布局实现。

另一方面，在 64 位体系结构（如 x86_64 和 ia64) 上，没有这样的限制。每个进程都可以从巨大的地址空间中受益。

### 虚拟内存管理
操作系统的物理内存架构通常对应用程序和用户是隐藏的，因为操作系统将任何内存映射到虚拟内存中。如果我们想了解 Linux 操作系统中的调优可能性，我们必须了解 Linux 如何处理虚拟内存。正如在 1.2.1 节 “物理和虚拟内存” 中所解释的，应用程序并不分配物理内存，而是在 Linux 内核中请求一个特定大小的内存映射，作为交换，在虚拟内存中接收一个映射。如 [@fig:vm_manage] 所示，虚拟内存不一定要映射到物理内存。如果应用程序分配了大量内存，其中一些内存可能会映射到磁盘子系统上的交换文件（_swap_）。

[@fig:vm_manage] 显示了应用程序通常不直接写入磁盘子系统，而是写入缓存或缓冲区。_pdflush_ 内核线程然后在有时间或文件大小超过缓冲区缓存时将缓存/缓冲区中的数据刷新到磁盘。请参阅 1.4.2 节的“刷新脏缓冲区”。

![Linux 虚拟内存管理器](images/vm_manage.jpg){#fig:vm_manage width=70% height=50%}

与 Linux 内核处理对物理磁盘子系统的写操作密切相关的是 Linux 内核管理磁盘缓存的方式。其他操作系统只分配一部分内存作为磁盘缓存，而 Linux 处理内存资源的效率要高得多。虚拟内存管理器的默认配置将所有可用的空闲内存空间分配为磁盘缓存。因此，经常会看到拥有数 GB 内存但只有 20MB 可用内存的高效 Linux 系统。

在同一上下文中，Linux 也非常有效地处理交换空间。交换空间的使用并不意味着内存瓶颈，而是证明了 Linux 处理系统资源的效率。详情请参阅本节下文的“页帧回收”。

#### 页帧分配

页是物理内存（页帧）或虚拟内存中一组连续的线性地址。Linux 内核使用这个页面单元来处理内存。一个页面通常有 4K 字节大小。当一个进程请求一定数量的页面时，如果有可用的页面，Linux 内核可以立即将它们分配给进程。否则，页面必须从其他进程或页面缓存中获取。内核知道有多少内存页可用，以及它们位于何处。

#### 伙伴系统（_Buddy system_）
Linux 内核使用一种称为伙伴系统（_Buddy system_）的机制来维护它的空闲页面。伙伴系统维护空闲页面，并尝试为页面分配请求分配页面。它试图保持内存区域的连续。如果小页面不加考虑地分散在一起，可能会导致内存碎片，而且将很大一部分页面分配到连续的区域会更加困难。它可能会导致内存使用效率低下和性能下降。[@fig:buddy_system] 展示了 伙伴系统如何分配页面。

![伙伴系统](images/buddy_system.jpg){#fig:buddy_system}

当页面分配尝试失败时，将激活页面回收。请参阅下文的“页帧回收”。

你可以通过`/proc/buddyinfo`找到关于伙伴系统的信息。详情请参见 2.3.5 节的"Memory used in a zone"。

#### 页帧回收
如果在进程请求映射一定数量的页面时页面不可用，则 Linux 内核试图通过释放某些页（这些页以前使用过，但不再使用，并且根据某些原则仍然标记为活动页）并将内存分配给新进程来获取新请求所需的页。这个过程称为页帧回收（_page reclaiming_）。_kswapd_ 内核线程和 `try_to_free_page()` 内核函数负责页面回收。

kswapd 通常在可中断状态中睡眠，当一个区域（zone）中的空闲页面低于阈值时，伙伴系统（_buddy system_）将调用它。它试图根据最近最少使用 (_LRU_) 原则从活动页面中找到要删除的候选页面。最近最少使用的页面应该首先被释放。活动（active）列表和非活动（inactive）列表用于维护候选页面。kswapd 扫描活动列表的一部分，并检查最近页面被使用的情况，将最近未使用的页面被放入非活动列表。您可以使用 `vmstat -a` 命令查看有多少内存被认为是活动的和不活动的。详情请参阅 2.3.2 节的 “vmstat”。

kswapd 还遵循另一个原则。页面主要用于两个目的：页面缓存（_page cache_）和进程地址空间（_process address space_）。页面缓存是映射到磁盘上文件的页面。属于进程地址空间的页面（称为匿名内存，因为它没有映射到任何文件，而且它没有名称）用于堆和堆栈。参考 [@sec:process_memory] "进程内存段"。当 kswapd 回收页面时，它宁愿收缩页面缓存，也不愿 page out（或 swap out）进程拥有的页面。

::: {.info caption="Page out 和 swap out"}
“page out” 和 “swap out” 这两个词有时令人困惑。“page out” 的意思是将一些页面（整个地址空间的一部分）放入交换空间，而 “swap out” 的意思是将整个地址空间放入交换空间。它们有时可以互换使用。
:::

被回收的页面缓存和被回收的进程地址空间的很大一部分可能取决于使用场景，并将影响性能。你可以使用 `/proc/sys/vm/swappiness` 来控制这种行为。请参阅 4.5.1 节，“设置内核交换和 pdflush 行为” 了解调优细节。

#### swap
如前所述，当发生页面回收时，属于进程地址空间的非活动列表中的候选页面可能会被换出。交换本身并不是问题。虽然交换只不过是在其他操作系统中主内存分配过多的情况下的一种保证，但 Linux 使用交换空间的效率要高得多。在 [@fig:vm_manage] 中可以看到，虚拟内存由物理内存和磁盘子系统或交换分区组成。如果 Linux 中的虚拟内存管理器意识到已经分配了一个内存页，但在很长一段时间内没有使用它，它会将这个内存页移动到交换空间。

通常，您会看到诸如 getty ^[getty 是 “get teletype” 的缩写，它是一个 Unix 程序，用来连接物理的或虚拟终端。] 之类的守护进程，它们将在系统启动时启动，但几乎不会被使用。 显然释放这种页面的昂贵主内存并将内存页面移动到交换分区会更有效。 Linux 正是这样处理 swap 的，所以不用担心 swap 分区被填满了 50%。swap 空间正在被使用的事实并不表示内存瓶颈； 相反，它证明了 Linux 处理系统资源的效率。