## Linux 进程管理

进程管理在任何操作系统中都是最重要的任务之一。高效的进程管理使应用程序能够稳定有效地运行。

Linux 进程管理实现类似于 UNIX® 实现。它包括进程调度、中断处理、信号发送、进程优先级、进程切换、进程状态、进程内存等等。

在本节中，我们将讨论 Linux 进程管理的原理。 这些知识可以帮助我们理解 Linux 内核是如何通过进程管理来影响系统性能的。

### 进程是什么？

进程是程序执行时运行在处理器上的一个实例。进程可以使用 Linux 内核可以处理的任何资源来完成它的任务。

Linux 操作系统上运行的所有进程都由 `task_struct` 结构体管理，该结构体也称为进程描述符（Process Descriptor）。进程描述符包含单个进程运行所需的所有信息，如进程标识、进程属性和构建进程的资源。如果您了解进程结构，就可以理解对进程执行和性能来说什么是重要的。[@fig:task_struct] 展示了进程结构概要。

```{#fig:task_struct .plot:dot caption="task_struct 结构体" height=50%}
digraph task_struct {
    node[shape="record"]
    rankdir="LR"
    subgraph cluster_task_struct {
        peripheries=0
        label="task_struct 结构体"
        task_struct[label="<state>state\n(Process State)|<thread>thread_info\n(Process information\n and kernel stack)|..|<que>run_list,array\n(For process scheduling)|..|<mm>mm\n(Process adress space)|..|pid\n(Process ID)|..|<group>group_info\n(Group managemet)|..|<user>user\n(User management)|..|<fs>fs\n(Working directory\nRoot directory)|<files>files\n(File descriptor)|..|<signal>signal\n(Signal information)|<sighand>sighand\n(Signal  handler)|.."]
    }
    
    subgraph cluster_thread_info {
        peripheries=0
        label="thread_info 结构体"
        thread_info[label="<task>task|exec_domain|flags|status|Kernel stack"]
    }
    
    subgraph cluster_other {
        peripheries=0
        label="其他结构体"
        runqueue[label="runqueue"]
        mm_struct[label="mm_struct"]
        group_info[label="group_info"]
        user_struct[label="user_struct"]
        fs_struct[label="fs_struct"]
        files_struct[label="files_struct"]
        signal_struct[label="signal_struct"]
        sighand_struct[label="sighand_struct"]
    }
    
    task_struct:thread -> thread_info:task
    thread_info:task:n -> task_struct:state
    task_struct:que -> runqueue
    task_struct:mm -> mm_struct
    task_struct:group -> group_info
    task_struct:user -> user_struct
    task_struct:fs -> fs_struct
    task_struct:files -> files_struct
    task_struct:signal -> signal_struct
    task_struct:sighand -> sighand_struct
}
```

### 进程的生命周期

每个进程都有自己的生命周期，如创建、执行、终止和删除。只要系统启动并运行，这些阶段就会重复数百万次。因此，从性能的角度来看，进程生命周期非常重要。[@fig:process_lifecycle] 展示了进程典型的生命周期。

```{#fig:process_lifecycle .plot:dot caption="进程生命周期"}
digraph task_struct {
    rankdir="LR"
    p1[label="parent\nprocess",group=g1]
    p2[label="parent\nprocess",group=g1]
    c1[label="child\nprocess",group=g2]
    c2[label="child\nprocess",group=g2]
    z[label="zombie\nprocess",group=g2]
    h1[shape="none",label=""]
    h2[shape="none",label=""]
    h1->p1
    p1->p2[label="wait()",style="dashed"]
    p2->h2
    p1->c1[label="fork()"]
    c1->c2[label="exec()"]
    c2->z[label="exit()", style="dashed"]
    z->p2
    {rank=same;p1;c1}
    {rank=same;p2;z}
    edge[style=invis];
    p2->z
}
```

当进程创建一个新的进程时，创建进程（父进程）发出 `fork()` 系统调用。当发出 `fork()` 系统调用时，它会为新创建的进程（子进程）获取一个进程描述符，并设置一个新的进程 ID。它会将父进程的进程描述符中所有数据复制到子进程。此时父进程的整个地址空间并没有被复制的，父子进程会共享相同的地址空间。

`exec()` 系统调用将新程序复制到子进程的地址空间。因为父子进程共享相同的地址空间，写入新的程序数据会导致页面错误异常（page fault）。此时，内核将会给子进程分配新的物理页。

这个延迟操作称为写时复制（_Copy On Write_）。子进程通常执行自己的程序，而不是与父进程执行相同的程序。这个操作避免了不必要的开销，因为复制整个地址空间是一个非常缓慢和低效的操作，会占用大量的处理器时间和资源。

当程序执行完成时，子进程通过 `exit()` 系统调用终止。`exit()` 系统调用释放进程的大部分数据结构，并发送信号通知父进程终止。此时，该进程被称为僵尸进程（_zombie process_）（参见第 1.1.7 节的“僵尸进程”)。

子进程不会被完全移除，直到父进程通过 `wait()` 系统调用知道它的子进程已经终止。一旦父进程收到子进程终止的通知，它就删除子进程的所有数据结构并释放进程描述符。

### 线程
线程（_thread_）是在单个进程中生成的执行单元。它与同一进程中的其他线程并行运行。它们可以共享相同的资源，如内存、地址空间、打开的文件等等。它们可以访问相同的应用程序数据集。线程也称为轻量级进程 (_Light Weight Process_ **LWP**)。因为它们共享资源，所以每个线程不应该同时更改它们的共享资源。互斥、锁、序列化等的实现由用户应用程序负责。

从性能角度来看，线程创建比进程创建成本低，因为线程不需要在创建时复制资源。另一方面，进程和线程在调度算法上具有相似的特点。内核以类似的方式处理它们。

:::{#fig:process_thread}
```{#fig:process_thread_process .plot:dot caption="进程创建" width=48% subfig=1}
digraph task_struct {
    rankdir="LR"
    compound=true
    subgraph cluster_p {
		subgraph cluster_p1 {
			style=filled
			color=cyan3
			
			node[style=filled,color=yellow]
			p1[label="resource",group=g1]
			label="Process"
			none1[shape="plaintext",label="",color=cyan3]
		}
		subgraph cluster_p2 {
			style=filled
			color=cyan3
			
			node[style=filled,color=yellow]
			p2[label="resource",group=g1]
			label="Process"
			none2[shape="plaintext",label="",color=cyan3]
		}
        none2->none1[lhead=cluster_p1,ltail=cluster_p2]
        p2->p1[label="copy",style="dashed"]
        peripheries=0
        labelloc="b"
        label="进程创建"
    }
    edge[style=invis]
    none1->none2
    p1->p2
}
```
```{#fig:process_thread_process .plot:dot caption="进程创建" width=48% subfig=1}
digraph task_struct {
    rankdir="TB"
    compound=true
    r[label="resource",group=g2,style=filled,color=yellow] 
    node[shape=none,style=invis]
    t1;t2;
    subgraph cluster_t {
        style=filled
        color=cyan3        
        peripheries=0
        subgraph cluster_t1 {
            style=filled
            color=slateblue
            label="Thread"
            t1
        }
        subgraph cluster_t2 {
            style=filled
            color=slateblue
            label="Thread"
            t2
        }
        r
        label="进程"
    }
    labelloc="b"
    label="线程创建"
    t2->t1[lhead=cluster_t1,ltail=cluster_t2]
    t1->r[label="share",style="dashed",ltail=cluster_t1]
    t2->r[headlabel="share",style="dashed",ltail=cluster_t2,labeldistance=6.5,labelangle=25]
    edge[style=invis]
    t1->t2
}
```

进程和线程
:::

In current Linux implementations, a thread is supported with the Portable Operating System Interface for UNIX (POSIX) compliant library (pthread).

在当前的 Linux 实现中，POSIX（可移植操作系统接口）兼容库（_pthread_）支持线程。在 Linux 操作系统中有几种线程实现可用。以下是广泛使用的。

LinuxThreads
:    
    LinuxThreads 自 Linux 内核 2.0 以来一直是默认的线程实现。LinuxThread 有一些与 POSIX 标准不兼容的实现。原生 POSIX 线程库（NPTL）正在取代 LinuxThreads。在未来的企业 Linux 发行版中不支持 LinuxThreads。

原生 POSIX 线程库（NPTL）
:    
    NPTL 最初是由红帽公司开发的。NPTL 更符合 POSIX 标准。通过利用内核 2.6 中的增强功能，比如新的 `clone()` 系统调用、信号处理实现等等，它比 LinuxThreads 有更好的性能和可伸缩性。
    
    NPTL 与 LinuxThreads 有一些不兼容性。依赖于 LinuxThread 的应用程序可能无法使用 NPTL 实现。

下一代 POSIX 线程库（NGPT）
:    
    NGPT 是 IBM 开发的 POSIX 线程库。它目前仍在维护，但没有进一步发展的计划。

使用 **LD_ASSUME_KERNEL** 环境变量，可以选择应用程序应该使用的线程库。

### 进程优先级和友好级（nice level）

### 上下文切换

### 中断处理

### 进程状态

### 进程内存段

### Linux CPU 调度器
