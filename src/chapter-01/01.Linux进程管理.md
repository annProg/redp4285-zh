## Linux 进程管理

进程管理在任何操作系统中都是最重要的任务之一。高效的进程管理使应用程序能够稳定有效地运行。

Linux 进程管理实现类似于 UNIX® 实现。它包括进程调度、中断处理、信号发送、进程优先级、进程切换、进程状态、进程内存等等。

在本节中，我们将讨论 Linux 进程管理的原理。 这些知识可以帮助我们理解 Linux 内核是如何通过进程管理来影响系统性能的。

### 进程是什么？

进程是程序执行时运行在处理器上的一个实例。进程可以使用 Linux 内核可以处理的任何资源来完成它的任务。

Linux 操作系统上运行的所有进程都由 `task_struct` 结构体管理，该结构体也称为进程描述符（Process Descriptor）。进程描述符包含单个进程运行所需的所有信息，如进程标识、进程属性和构建进程的资源。如果您了解进程结构，就可以理解对进程执行和性能来说什么是重要的。[@fig:task_struct] 展示了进程结构概要。

```{#fig:task_struct .plot:dot caption="task_struct 结构体" height=50%}
digraph task_struct {
    node[shape="record"]
    rankdir="LR"
    subgraph cluster_task_struct {
        peripheries=0
        label="task_struct 结构体"
        task_struct[label="<state>state\n(Process State)|<thread>thread_info\n(Process information\n and kernel stack)|..|<que>run_list,array\n(For process scheduling)|..|<mm>mm\n(Process adress space)|..|pid\n(Process ID)|..|<group>group_info\n(Group managemet)|..|<user>user\n(User management)|..|<fs>fs\n(Working directory\nRoot directory)|<files>files\n(File descriptor)|..|<signal>signal\n(Signal information)|<sighand>sighand\n(Signal  handler)|.."]
    }
    
    subgraph cluster_thread_info {
        peripheries=0
        label="thread_info 结构体"
        thread_info[label="<task>task|exec_domain|flags|status|Kernel stack"]
    }
    
    subgraph cluster_other {
        peripheries=0
        label="其他结构体"
        runqueue[label="runqueue"]
        mm_struct[label="mm_struct"]
        group_info[label="group_info"]
        user_struct[label="user_struct"]
        fs_struct[label="fs_struct"]
        files_struct[label="files_struct"]
        signal_struct[label="signal_struct"]
        sighand_struct[label="sighand_struct"]
    }
    
    task_struct:thread -> thread_info:task
    thread_info:task:n -> task_struct:state
    task_struct:que -> runqueue
    task_struct:mm -> mm_struct
    task_struct:group -> group_info
    task_struct:user -> user_struct
    task_struct:fs -> fs_struct
    task_struct:files -> files_struct
    task_struct:signal -> signal_struct
    task_struct:sighand -> sighand_struct
}
```

### 进程的生命周期

每个进程都有自己的生命周期，如创建、执行、终止和删除。只要系统启动并运行，这些阶段就会重复数百万次。因此，从性能的角度来看，进程生命周期非常重要。[@fig:process_lifecycle] 展示了进程典型的生命周期。

```{#fig:process_lifecycle .plot:dot caption="进程生命周期"}
digraph task_struct {
    rankdir="LR"
    p1[label="parent\nprocess",group=g1]
    p2[label="parent\nprocess",group=g1]
    c1[label="child\nprocess",group=g2]
    c2[label="child\nprocess",group=g2]
    z[label="zombie\nprocess",group=g2]
    h1[shape="none",label=""]
    h2[shape="none",label=""]
    h1->p1
    p1->p2[label="wait()",style="dashed"]
    p2->h2
    p1->c1[label="fork()"]
    c1->c2[label="exec()"]
    c2->z[label="exit()", style="dashed"]
    z->p2
    {rank=same;p1;c1}
    {rank=same;p2;z}
    edge[style=invis];
    p2->z
}
```

当进程创建一个新的进程时，创建进程（父进程）发出 `fork()` 系统调用。当发出 `fork()` 系统调用时，它会为新创建的进程（子进程）获取一个进程描述符，并设置一个新的进程 ID。它会将父进程的进程描述符中所有数据复制到子进程。此时父进程的整个地址空间并没有被复制的，父子进程会共享相同的地址空间。

`exec()` 系统调用将新程序复制到子进程的地址空间。因为父子进程共享相同的地址空间，写入新的程序数据会导致页面错误异常（page fault）。此时，内核将会给子进程分配新的物理页。

这个延迟操作称为写时复制（__Copy On Write__）。子进程通常执行自己的程序，而不是与父进程执行相同的程序。这个操作避免了不必要的开销，因为复制整个地址空间是一个非常缓慢和低效的操作，会占用大量的处理器时间和资源。

当程序执行完成时，子进程通过 `exit()` 系统调用终止。`exit()` 系统调用释放进程的大部分数据结构，并发送信号通知父进程终止。此时，该进程被称为僵尸进程（__zombie process__）（参见第 1.1.7 节的“僵尸进程”)。

子进程不会被完全移除，直到父进程通过 `wait()` 系统调用知道它的子进程已经终止。一旦父进程收到子进程终止的通知，它就删除子进程的所有数据结构并释放进程描述符。