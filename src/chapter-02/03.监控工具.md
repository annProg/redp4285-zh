## 监控工具
在本节中，我们将讨论监控工具。大多数工具都是在 Enterprise Linux 发行版中提供的。您应该熟悉这些工具。

### top
top 命令实时显示进程活动。默认情况下，top 显示占用 CPU 最多的任务，并每 5 秒更新一次列表。您也可以按 PID（数值）、age（最新在前）、time（累积时间）、驻留内存（resident memory）使用情况和 time（进程自启动以来占用 CPU 的时间）对进程进行排序。

```{#lst:example_top .bash caption="top 命令输出示例"}
top - 19:41:32 up 15 days, 19:49,  1 user,  load average: 0.25, 0.21, 0.18
Tasks: 189 total,   1 running, 188 sleeping,   0 stopped,   0 zombie
%Cpu(s):  1.3 us,  5.1 sy,  0.0 ni, 93.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :   3793.3 total,    250.2 free,    815.1 used,   2727.9 buff/cache
MiB Swap:      0.0 total,      0.0 free,      0.0 used.   2927.1 avail Mem 

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
 699270 ubuntu    20   0   10688   3084   2716 R  17.6   0.1   0:00.05 top
      1 root      20   0  173720  14292   7472 S   0.0   0.4  15:09.93 systemd
      2 root      20   0       0      0      0 S   0.0   0.0   0:03.27 kthreadd
      3 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_gp
      4 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_par_gp
      8 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 mm_percpu_wq
      9 root      20   0       0      0      0 S   0.0   0.0   6:39.65 ksoftirqd/0
     10 root      20   0       0      0      0 I   0.0   0.0  19:52.54 rcu_preempt
     11 root      rt   0       0      0      0 S   0.0   0.0   0:10.36 migration/0
     12 root     -51   0       0      0      0 S   0.0   0.0   0:00.00 idle_inject/0
     14 root      20   0       0      0      0 S   0.0   0.0   0:00.00 cpuhp/0
     15 root      20   0       0      0      0 S   0.0   0.0   0:00.00 cpuhp/1
     16 root     -51   0       0      0      0 S   0.0   0.0   0:00.00 idle_inject/1
     17 root      rt   0       0      0      0 S   0.0   0.0   0:10.14 migration/1
     18 root      20   0       0      0      0 S   0.0   0.0   0:41.60 ksoftirqd/1
```

您可以使用 **renice** 进一步修改进程，为每个进程赋予新的优先级。当某个进程挂起或占用过多 CPU 时，可以使用 **kill** 命令杀死该进程。

各列的含义：

PID
:	进程标识

USER
:	拥有（可能是启动）进程的用户名。

PRI^[原文为 PRI，应对应 top 输出的 PR]
:	进程的优先级。（详见 1.1.4 节 “进程优先级和 nice 级别”)

NI
:	nice 级别（进程是否尝试通过给定的数字调整优先级来达到亲和性。详情请看下文）。

SIZE^[原文为 SIZE，应对应 top 输出的 VIRT]
:	进程使用的内存数量（code+data+stack），单位为千字节。

RSS^[原文为 RSS，应对应 top 输出的 RES]
:	使用的物理 RAM 数量，单位为千字节。

SHARE^[原文为 SHARE，应对应 top 输出的 SHR]
:	与其他进程共享的内存量，单位为千字节。

STAT^[原文为 STAT，应对应 top 输出的 S]
:	进程状态：S=休眠（sleeping），R=运行（running），T=停止或跟踪（stopped or traced），D =可中断睡眠（interruptible sleep），Z =僵尸（zombie）。参见 1.1.7 节“进程状态”。

%CPU
:	CPU 使用率（自上次屏幕更新以来）。

%MEM
:	内存使用率

TIME
:	进程使用的总 CPU 时间（自它启动以来）。

COMMAND
:	用于启动任务的命令行（包括参数）。

top 实用程序支持几个有用的热键，包括：

t
:	显示摘要信息开关。

m 
:	显示内存信息开关。

A 
:	根据各种系统资源的顶级消费者对显示进行排序，有助于快速识别系统中影响性能的任务。

f 
:	进入 **top** 的交互式配置屏幕。有助于为特定的任务设置 **top**。

o
:	使您能够交互式地选择顶部的排序。

r
:	执行 **renice** 命令。

k 
:	执行 **kill** 命令。

### vmstat
vmstat 提供有关进程、内存、分页、block I/O、traps 和 CPU 活动的信息。vmstat 命令显示平均数据或实时采样值。通过向 vmstat 提供采样频率和采样持续时间，可以启用采样模式。

::: {.warn}
在采样模式下，考虑实际数据收集之间出现峰值的可能性。将采样频率降到一个较低的值可以避免错过这些隐藏的峰值。
:::

```{#lst:vmstat .bash caption="vmstat 的输出示例"}
ubuntu@ubuntu:~$ vmstat 2
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  1      0 253180 203836 2589972    0    0     1    51    1    5  1  1 98  0  0
 1  0      0 253432 203836 2589972    0    0     0   480 1078 1579  1  1 97  1  0
 0  0      0 253432 203836 2589972    0    0     0   526 1104 1588  1  1 96  1  0
 1  1      0 253432 203836 2589972    0    0     0   438  874 1280  1  1 96  2  0
 0  0      0 253464 203836 2589972    0    0     0   358 1007 1415  1  1 87 11  0
 0  0      0 253464 203836 2589972    0    0     0   528  895 1293  1  1 97  1  0
```

::: {.info}
vmstat 报告的第一行数据显示了自上次重新引导以来的平均值，因此应该删除它。
:::

vmstat 的输出列如下：

Process (procs)
:	r: 等待运行时的进程数
	b: 处于不可中断休眠状态的进程数

Memory
:	swpd: 使用的虚拟内存数量 (KB)
	free: 空闲内存数量 (KB)
	buff: 作为缓冲区使用的内存数量 (KB)
	cache: The amount of memory used as cache (KB)

Swap
:	si: 从磁盘换入的内存数量 (KBps)
	so: 换出到磁盘的内存数量 (KBps)

IO
:	bi: 发送到块设备的块 (blocks/s)
	bo: 从块设备接收的块 (blocks/s)

System
:	in: 每秒钟中断的数量，包括时钟中断
	cs：每秒上下文切换的数量

CPU(% of total CPU time)
:	us: 运行非内核代码的时间（用户时间，包括 nice time）。
	sy: 运行内核代码所花费的时间（系统时间）。
	id: 空闲的时间。在 Linux 2.5.41 之前，这包括 I/O 等待时间。
	wa: 等待 IO 的时间。在 Linux 2.5.41 之前，这个值为 0。

vmstat 命令支持大量的命令行参数，这些参数在 vmstat 的手册页中有完整的记录。一些更有用的标志包括：

-m
:	显示内核的内存利用率（slabs）

-a
:	提供有关活动和非活动内存页的信息

-n
:	只显示一个标题行（do not redisplay header），如果需要在采样模式下运行 vmstat 并通过管道将结果输出到文件中，这个参数很有用。（例如，`root# vmstat -n 2 10` 以 2 秒的频率采样 10 次）。

当与 `-p` {partition} 标志^[ -p, --partition <dev>  partition specific statistics，如 vmstat -p /dev/sda1] 一起使用时，**vmstat** 还提供 I/O 统计信息。

### uptime
可以使用 uptime 命令查看服务器已经运行了多长时间，有多少用户登录，以及快速概述服务器的平均负载。（请参阅 1.6.1 节“处理器指标”)。uptime 可以显示过去 1 分钟、5 分钟和 15 分钟的系统平均负载值。

负载的最佳值是 1，这意味着每个进程都可以立即访问 CPU，并且不会错过 CPU 周期。典型的负载可能因系统而异。对于单处理器工作站，1 或 2 可能是可以接受的，而在多处理器服务器上，您可能会看到值为 8 到 10。

您可以使用 **uptime** 来确定是服务器还是网络出了问题。例如，如果一个网络应用程序运行得很差，执行 **uptime** 您将看到系统负载是否很高。如果不是，则问题更可能与您的网络有关，而不是与您的服务器。

::: {.info}
你可以用 **w** 代替 **uptime**。**w** 命令还提供有关当前登录到计算机的用户以及用户正在做什么的信息。
:::

```{#lst:uptime_output .bash caption="uptime 输出示例"}
 21:33:35 up 16 days, 21:41,  1 user,  load average: 0.22, 0.20, 0.18
```

### ps and pstree
当涉及到系统分析时，**ps** 和 **pree** 命令是一些最基本的命令。**ps** 可以有 3 种不同类型的命令选项，UNIX 风格、BSD 风格和 GNU 风格。这里我们看看 UNIX 风格的选项。

**ps** 命令提供现有进程的列表。**top** 命令显示进程信息，但是 **ps** 将提供更详细的信息。列出的进程数量取决于所使用的选项。一个简单的 `ps -A` 命令列出了所有进程及其各自的进程 ID（PID），这些进程 ID 对进一步的研究至关重要。为了使用 **pmap** 或 **renice** 等工具，需要一个 PID 数字。

在运行 Java™ 应用程序的系统上，`ps -A` 命令的输出可能会很容易地填满显示，以至于很难获得所有正在运行的进程的完整图像。在这种情况下，**pstree** 命令可能会派上用场，因为它以树结构显示正在运行的进程，并合并生成的子进程（例如，Java 线程）。**pstree** 命令可以帮助识别原始进程。还有另一种 **ps** 变体，**pgrep**。这可能也很有用。

```{#lst:ps_output .bash caption="ps 输出示例"}
ubuntu@ubuntu:~$ ps -A
    PID TTY          TIME CMD
      1 ?        00:19:25 systemd
      2 ?        00:00:04 kthreadd
      3 ?        00:00:00 rcu_gp
      4 ?        00:00:00 rcu_par_gp
      8 ?        00:00:00 mm_percpu_wq
      9 ?        00:11:32 ksoftirqd/0
     10 ?        00:27:53 rcu_preempt
     11 ?        00:00:13 migration/0
```

以下是一些 **ps** 常用的选项。

-e
:	同 **-A**，显示所有进程

-l 
:	显示为长格式

-F 
:	完整模式（Extra full mode）

-H
:	层次结构显示（Forest）

-L 
:	显示线程，可能使用 LWP 和 NLWP 列

-m 
:	在进程之后显示线程

[@lst:ps_detail] 是使用 `ps -elFL` 参数的详细输出示例。

```{#lst:ps_detail .bash caption="ps 详细输出示例"}
ubuntu@ubuntu:~$ ps -elFL
F S UID          PID    PPID     LWP  C NLWP PRI  NI ADDR SZ WCHAN    RSS PSR STIME TTY          TIME CMD
4 S root           1       0       1  0    1  80   0 - 43430 -      14292   2 Aug02 ?        00:19:24 /lib/systemd/systemd --system --deserialize 86
1 S root           2       0       2  0    1  80   0 -     0 -          0   1 Aug02 ?        00:00:04 [kthreadd]
1 I root           3       2       3  0    1  60 -20 -     0 -          0   0 Aug02 ?        00:00:00 [rcu_gp]
1 I root           4       2       4  0    1  60 -20 -     0 -          0   0 Aug02 ?        00:00:00 [rcu_par_gp]
1 I root           8       2       8  0    1  60 -20 -     0 -          0   0 Aug02 ?        00:00:00 [mm_percpu_wq]
1 S root           9       2       9  0    1  80   0 -     0 -          0   0 Aug02 ?        00:11:33 [ksoftirqd/0]
1 I root          10       2      10  0    1  80   0 -     0 -          0   0 Aug02 ?        00:27:54 [rcu_preempt]
1 S root          11       2      11  0    1 -40   - -     0 -          0   0 Aug02 ?        00:00:13 [migration/0]
5 S root          12       2      12  0    1   9   - -     0 -          0   0 Aug02 ?        00:00:00 [idle_inject/0]
```

[@lst:ps_detail] 中输出各列的含义如下：

F
:	进程标志（Process flag）

S
:	进程状态：S=sleeping, R=running, T=stopped or traced,D=interruptable sleep, Z=zombie. 进程状态更深入的讨论见 1.1.7 节的 “进程状态”。

UID
:	拥有（可能是启动）进程的用户。

PID
:	进程 ID。

PPID
:	父进程 ID。

LWP
:	LWP（light weight process,or thread 轻量级进程或线程）所报告的 LWP 的 ID。

C 
:	处理器利用率百分比的整数值。(CPU 使用）。

NLWP
:	进程中的 lwps（线程）数量。（别名 thcount)。

PRI
:	进程的优先级。（详见 1.1.4 节的 “进程优先级和 nice 级别”)。

NI
:	亲和性（Niceness）级别（进程是否通过根据给定的数字调整优先级来尝试达到亲和性）。

ADDR
:	进程地址空间（未显示）

SZ
:	进程使用的内存数量（代码+数据+堆栈），单位为千字节。

WCHAN
:	进程处于休眠状态的内核函数的名称，如果进程正在运行，则用 "-" 表示；如果进程是多线程的，且 ps 没有显示线程，则用 "*" 表示。

RSS
:	常驻内存集大小，任务使用的非交换物理内存（单位为千字节）。

PSR
:	当前分配给该进程的处理器。

STIME
:	命令开始执行的时间。

TTY
:	终端（Terminal）。

TIME
:	进程使用的总 CPU 时间（自它启动以来）。

CMD
:	用于启动任务的命令行（包括参数）。

#### 线程信息
可以使用 `ps -L` 选项查看线程信息。

```{#lst:ps_thread .bash caption="ps -L 输出"}
[root@edam ~]# ps -eLF| grep -E "LWP|/usr/sbin/httpd"
UID    PID PPID  LWP  C NLWP SZ RSS PSR STIME TTY TIME CMD
root   4504 1    4504 0 1 4313 8600 2 08:33 ? 00:00:00 /usr/sbin/httpd
apache 4507 4504 4507 0 1 4313 4236 1 08:33 ? 00:00:00 /usr/sbin/httpd
apache 4508 4504 4508 0 1 4313 4228 1 08:33 ? 00:00:00 /usr/sbin/httpd
apache 4509 4504 4509 0 1 4313 4228 0 08:33 ? 00:00:00 /usr/sbin/httpd
apache 4510 4504 4510 0 1 4313 4228 3 08:33 ? 00:00:00 /usr/sbin/httpd

[root@edam ~]# ps -eLF| grep -E "LWP|/usr/sbin/httpd"
UID    PID PPID  LWP  C NLWP SZ  RSS PSR STIME TTY TIME  CMD
root   4632 1    4632 0 1  3640  7772 2 08:44 ? 00:00:00 /usr/sbin/httpd.worker
apache 4635 4632 4635 0 27 72795 5352 3 08:44 ? 00:00:00 /usr/sbin/httpd.worker
apache 4635 4632 4638 0 27 72795 5352 1 08:44 ? 00:00:00 /usr/sbin/httpd.worker
apache 4635 4632 4639 0 27 72795 5352 3 08:44 ? 00:00:00 /usr/sbin/httpd.worker
apache 4635 4632 4640 0 27 72795 5352 3 08:44 ? 00:00:00 /usr/sbin/httpd.worker
```

### free
命令 **/bin/free** 显示系统中空闲和使用的内存总数（包括 swap)。它还包括关于内核使用的缓冲区和缓存的信息。

```{#lst:free_output .bash caption="free 命令输出"}
root@ubuntu:~# free
              total        used        free      shared  buff/cache   available
Mem:        3884328      825540      552268        9328     2506520     3000016
Swap:             0           0           0
```

在使用 **free** 时，请记住 Linux 内存体系结构和虚拟内存管理器的工作方式。可用内存的数量是有限的，而且交换的纯利用率统计数据并不表明存在内存瓶颈。

[@fig:free_output] 描述了 **free** 命令输出显示的基本思想。

![free 命令输出](images/free_output.jpg){#fig:free_output width=80%}

**free** 命令一些有用的参数：

-b,-k,-m,-g
:	以字节、千字节、兆字节和千兆字节显示值

-l
:	低内存和高内存的区别（参考 1.2 节的 “Linux 内存架构”)。

-c <count>
:	显示输出 `<count>` 次

#### 区域（zone）内使用的内存
使用 `-l` 选项，可以看到每个内存区域使用了多少内存。[@lst:free_32] 和 [@lst:free_64] 显示了 32 位和 64 位系统的 `free -l` 输出示例。注意，64 位系统不再使用高内存。

```{#lst:free_32 .bash caption="在 32 位版本内核上使用 free 命令的输出信息"}
root@ubuntu:~# free -l
              total        used        free      shared  buff/cache   available
Mem:        4154484      2381500      1772984        9328     2506552     2999528
Low:         877828       199436       678392
High:       3276656      2182064      1094592
Swap:             0           0           0
```

```{#lst:free_32 .bash caption="在 64 位版本内核上使用 free 命令的输出信息"}
root@ubuntu:~# free -l
              total        used        free      shared  buff/cache   available
Mem:        3884328      826028      551748        9328     2506552     2999528
Low:        3884328     3332580      551748
High:             0           0           0
Swap:             0           0           0
```

还可以使用 `/proc/buddyinfo` 文件确定每个区域中有多少块（chunks）内存可用。每一列数字表示该 order 中可用的页数。在 [@lst:buddyinfo] 中，`ZONE_DMA` 中有 5 个 `2^2*PAGE_SIZE` 的块可用，`ZONE_DMA32` 中有 16 个 `2^3*PAGE_SIZE` 的块可用。记住伙伴（buddy）系统是如何分配页面的（请参阅第一章的“伙伴系统”)。该信息显示内存的碎片程度，并让您了解可以安全地分配多少页面。

```{#lst:buddyinfo .bash caption="64 位系统的 Buddy 系统"}
[root@lnxsu5 ~]# cat /proc/buddyinfo
Node 0, zone    DMA  1  3 5  4 6 1 1 0  2  0   2
Node 0, zone  DMA32 56 14 2 16 7 3 1 7 41 42 670
Node 0, zone Normal  0  6 3  2 1 0 1 0  0  1   0
```

### iostat
**iostat** 命令显示自系统启动以来的平均 CPU 时间（类似于正常运行时间）。它还将创建服务器磁盘子系统活动的报告，该报告分为两个部分：CPU 利用率和设备（磁盘）利用率。要使用 **iostat** 来执行详细的 I/O 瓶颈和性能调优，请参阅 3.4.1 节“定位磁盘瓶颈”。iostat 实用程序是 sysstat 包的一部分。

```{#lst:iostat_output .bash caption="iostat 输出示例"}
Linux 5.4.0-1038-raspi (ubuntu) 	08/25/21 	_aarch64_	(4 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.81    0.05    0.67    0.69    0.00   97.78

Device             tps    kB_read/s    kB_wrtn/s    kB_dscd/s    kB_read    kB_wrtn    kB_dscd
loop0             0.00         0.00         0.00         0.00        763          0          0
loop1             0.00         0.00         0.00         0.00       1935          0          0
loop2             0.00         0.00         0.00         0.00        380          0          0
sda               0.07         0.62         5.87         0.00    1227249   11542897          0
```

CPU 利用率报告有四个部分：

%user
:	显示在用户级（应用程序）执行时占用的 CPU 使用率百分比。

%nice
:	显示在具有 nice 优先级的用户级别执行时占用的 CPU 使用率百分比。（优先级和 nice 级别详见下节的“nice, renice”）。

%sys
:	显示在系统级（内核）执行时占用的 CPU 使用率百分比。

%idle
:	显示 CPU 空闲的时间百分比。

设备利用率报告分为以下几部分：

Device
:	块设备的名称。

tps
:	每秒传输（transfers per second）到设备的次数（每秒 I/O 请求）。多个单个 I/O 请求可以组合在一个传输请求中，因为一个传输请求可以有不同的大小。

Blk_read/s,Blk_wrtn/s
:	每秒读写块数”表示设备的读写数据量（以秒为单位）。块也可以有不同的大小。典型的大小是 1024、2048、4048 字节，具体取决于分区大小。例如，/dev/sda1 的块大小可以通过以下方式找到：

	```bash
	dumpe2fs -h /dev/sda1 |grep -F "Block size"
	```

	输出形式为：

	```bash
	dumpe2fs 1.34 (25-Jul-2003)
	Block size: 1024
	```

Blk_read,Blk_wrtn
:	表示自引导以来读和写的块总数。

**iostat** 可以使用许多选项。从性能角度来看，最有用的是 `-x` 选项。它显示扩展的统计信息。下面是示例输出。

```{#lst:iostat_x .bash caption="iostat -x 输出"}
[root@dev ~]# iostat -d -x /dev/sda 1
Linux 4.19.5-1.el7.elrepo.x86_64 (dev) 	2021 年 08 月 06 日 	_x86_64_	(4 CPU)

Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
sda               0.02     0.25    0.29    0.31     8.43    10.20    62.03     0.01    8.49   10.73    6.46   1.76   0.11
```

rrqm/s, wrqm/s
:	每秒下发到设备的合并读写请求数。多个单个 I/O 请求可以合并到一个传输请求中，因为一个传输请求可以有不同的大小。

r/s, w/s
:	每秒发送到设备的读/写请求数。

rsec/s, wsec/s
:	每秒设备读写扇区（sectors）数。

rkB/s, wkB/s
:	每秒从设备读/写的千字节数。

avgrq-sz
:	向设备发出的请求的平均大小。以扇区的形式显示。

avgqu-sz
:	向设备发出的请求的平均队列长度。

await
:	显示在系统级（内核）执行时所使用的 CPU 使用率百分比。

svctm
:	向设备发出 I/O 请求的平均服务时间（以毫秒为单位）。

%util
:	向设备发出 I/O 请求的 CPU 时间百分比（设备的带宽利用率）。当这个值接近 100% 时，设备饱和发生。

为了根据访问模式调整磁盘子系统，计算平均 I/O 大小可能是有用的。下面的示例是使用带有 **-d** 和 **-x** 选项的 **iostat** 只显示有关感兴趣的磁盘子系统的信息：

```{#lst:iostat_x_d .bash caption="使用 iostat -x -d 分析平均 I/O 大小"}
Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
sda               0.02     0.25    0.29    0.31     8.43    10.20    62.03     0.01    8.49   10.73    6.46   1.76   0.11
```

[@lst:iostat_x_d] 中的 **iostat** 输出显示设备 sda 每秒必须写入 10.20 KB 的数据，这些数据显示在 **wkB/s** 标题下。这个数据量以 0.31 I/O 的方式发送到磁盘子系统，如上例中的 **w/s** 所示。平均 I/O 大小或平均请求大小显示在 **avgrq-sz** 下，在我们的示例中为 62.03 块 512 字节（blocks of 512 byte）。对于异步写，平均 I/O 大小通常是某个奇数。然而，大多数应用程序以 4 KB（例如 4 KB、8 KB、16 KB、32 KB 等等）的倍数执行读写 I/O。在上面的例子中，应用程序只发出 4 KB 的随机写请求，但是 iostat 显示的平均请求大小为 4.915 KB。这种差异是由 Linux 文件系统造成的，尽管我们正在执行随机写操作，但仍然发现一些 I/O 可以合并在一起，以便更有效地刷新到磁盘子系统。

:::{.info}
当文件系统使用默认异步模式时，只有 iostat 中显示的平均请求大小是正确的。即使应用程序以不同的大小执行写请求，Linux 的 I/O 层也很可能合并，从而改变平均 I/O 大小。
:::

### sar
**sar** 命令用于收集、报告和保存系统活动信息。**sar** 命令由三个应用程序组成：**sar**，用于显示数据，以及 **sa1** 和 **sa2**，用于收集和存储数据。**sar** 工具具有广泛的选项，因此请务必查看手册页。**sar** 实用程序是 sysstat 包的一部分。

使用 **sa1** 和 **sa2**，可以将系统配置为获取信息并将其记录下来以供以后分析。

:::{.info caption="提示"}
我们建议您在大部分（如果不是全部）系统上运行 **sar**。在出现性能问题的情况下，您将以非常小的开销和没有额外成本获得非常详细的手边信息。
:::

为此，将这些行添加到 `/etc/crontab`（[@lst:sar_cron])。请记住，在系统上安装 **sar** 之后，会自动设置一个默认的每天运行 **sar** 的 **cron** 作业。

```{#lst:sar_cron .bash caption="使用 cron 启动自动日志报告的示例"}
# 8am-7pm activity reports every 10 minutes during weekdays.
*/10 8-18 * * 1-5 /usr/lib/sa/sa1 600 6 &
# 7pm-8am activity reports every an hour during weekdays.
0 19-7 * * 1-5 /usr/lib/sa/sa1 &
# Activity reports every an hour on Saturday and Sunday.
0 * * * 0,6 /usr/lib/sa/sa1 &
# Daily summary prepared at 19:05
5 19 * * * /usr/lib/sa/sa2 -A &
```

**sar** 工具的原始数据存储在 `/var/log/sa/` 下，其中各种文件表示每个月的天数。要检查结果，请选择当月的工作日和请求的性能数据。例如，要显示从第 21 天开始的网络计数器，可以使用命令 **sar -n DEV -f sa21**，并将其管道到 **less**，如 [@lst:sar_f] 所示。

```{#lst:sar_f .bash caption="使用 sar 显示系统统计信息"}
[root@dev ~]# sar -n DEV -f /var/log/sa/sa27 | less
Linux 4.19.5-1.el7.elrepo.x86_64 (dev) 	2021 年 08 月 27 日 	_x86_64_	(4 CPU)

15:40:01     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s
15:50:01     ens33      0.05      0.05      0.00      0.00      0.00      0.00      0.00
15:50:01     ens36      0.14      0.13      0.01      0.01      0.00      0.00      0.00
15:50:01        lo      0.10      0.10      0.03      0.03      0.00      0.00      0.00
15:50:01   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00
```

还可以直接在命令行运行 **sar** 来查看接近实时的系统运行报告，见 [@lst:sar_u]。

```{#lst:sar_u .bash caption="临时（Ad hoc） CPU 监控"}
[root@dev ~]# sar -u 3 5
Linux 4.19.5-1.el7.elrepo.x86_64 (dev) 	2021 年 08 月 28 日 	_x86_64_	(4 CPU)

01 时 40 分 31 秒     CPU     %user     %nice   %system   %iowait    %steal     %idle
01 时 40 分 34 秒     all      0.00      0.00      0.08      0.00      0.00     99.92
01 时 40 分 37 秒     all      0.00      0.00      0.17      0.00      0.00     99.83
01 时 40 分 40 秒     all      0.00      0.00      0.08      0.00      0.00     99.92
01 时 40 分 43 秒     all      0.08      0.00      0.08      0.00      0.00     99.83
01 时 40 分 46 秒     all      0.00      0.00      0.08      0.00      0.00     99.92
平均时间：            all      0.02      0.00      0.10      0.00      0.00     99.88
```

从收集的数据中，您可以看到 CPU 利用率的详细概述（%user， %nice，%system， %idle），内存分页，网络 I/O 和传输统计信息，进程创建活动，块设备的活动，以及随时间变化的每秒中断数量。

### mpstat
**mpstat** 命令用于报告多处理器服务器上每个可用 CPU 的活动。还报告了所有 CPU 的全局平均活动。**mpstat** 实用程序是 sysstat 包的一部分。

**mpstat** 实用程序使您能够显示每个系统或每个处理器的总体 CPU 统计信息。**mpstat** 还支持在采样模式中创建统计信息，类似于 **vmstat** 命令，它具有采样频率和采样计数。[@lst:mpstat] 显示了使用 **mpstat -P ALL** 创建的示例输出，以显示每个处理器的平均 CPU 利用率。

```{#lst:mpstat .bash caption="多处理器系统上 mpstat 命令的输出"}
[root@dev ~]# mpstat -P ALL
Linux 4.19.5-1.el7.elrepo.x86_64 (dev) 	2021 年 08 月 28 日 	_x86_64_	(4 CPU)

01 时 47 分 24 秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
01 时 47 分 24 秒  all    0.04    0.00    0.12    0.01    0.00    0.00    0.00    0.00    0.00   99.82
01 时 47 分 24 秒    0    0.05    0.00    0.11    0.02    0.00    0.00    0.00    0.00    0.00   99.82
01 时 47 分 24 秒    1    0.04    0.00    0.12    0.01    0.00    0.01    0.00    0.00    0.00   99.82
01 时 47 分 24 秒    2    0.05    0.00    0.11    0.01    0.00    0.00    0.00    0.00    0.00   99.82
01 时 47 分 24 秒    3    0.03    0.00    0.13    0.01    0.00    0.01    0.00    0.00    0.00   99.82
```

使用 `mpstat -P ALL 1 1` 命令以一秒的时间间隔显示多处理器服务器上所有处理器的两个统计信息。

```
[root@dev ~]# mpstat -P ALL 1 1
Linux 4.19.5-1.el7.elrepo.x86_64 (dev) 	2021 年 08 月 28 日 	_x86_64_	(4 CPU)

01 时 49 分 27 秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
01 时 49 分 28 秒  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
01 时 49 分 28 秒    0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
01 时 49 分 28 秒    1    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
01 时 49 分 28 秒    2    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
01 时 49 分 28 秒    3    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00

平均时间：CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
平均时间：all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
平均时间：0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
平均时间：1    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
平均时间：2    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
平均时间：3    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
```

要查看 mpstat 命令的完整语法，使用 `mpstat -?`。

### numastat

### pmap

### netstat

### iptraf

### tcpdump/ethereal

### nmon

### strace

### Proc file system

### KED System Guard

### Gnome System Monitor

### 容量管理